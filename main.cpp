#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <stdio.h>

//=====НАША СТРУКТУРА========
struct Node
{
    Node *l,*r; //левое и правое поддерево
    int x; //Некоторые данные
};

/*ФУНКЦИЯ ДОБАВЛЕНИЯ ЗВЕНА В ДЕРЕВО*/
void add(int x,Node *&MyTree) //Функция добавления звена в дерево
{
    if (NULL==MyTree)  //То, о чем я в самом начале писал. Если дерева нет, то сеем семечко
    {
        MyTree=new Node; //Выделяем память под звено дерева
        MyTree->x=x; //Записываем данные в звено
        MyTree->l=MyTree->r=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
    }

                   if (x<MyTree->x)   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
                      {
                          if (MyTree->l!=NULL) add(x,MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->l=new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
                              MyTree->l->l=MyTree->l->r=NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->l->x=x; //Записываем в левое подзвено записываемый элемент
                          }
                      }

                    if (x>MyTree->x)   //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
                      {
                          if (MyTree->r!=NULL) add(x,MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->r=new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
                              MyTree->r->l=MyTree->r->r=NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->r->x=x; //Записываем в правое подзвено записываемый элемент
                          }
                      }

}

/*ОБХОД В ПРЯМОМ ПОРЯДКЕ*/
 void Show(Node *&tree)
{
    if (NULL==tree)    return;    //Если дерева нет, выходим

    printf("%d", tree->x);//cout<<tree->x<<endl; //Посетили узел
    Show(tree->l); //Обошли левое поддерево
    Show(tree->r); //Обошли правое поддерево
}
#include <iostream>
#include <string>
int main()
{
    int x; //Некоторые данные
    Node *MyTree=NULL; //Указатель на нашу структуру. Инициализируем во избежание ошибок

  for (int i=0;i<7;i++) //В дереве будет 7 узлов
  {
      printf("X = \n");
       cin>>x; //Ввели X с клавиатуры
      add(x,MyTree); //Добавили X в дерево
  }

  Show(MyTree); //Обошли дерево и показали его звенья в линейном порядке
}



